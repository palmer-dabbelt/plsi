# Core configuration options and defaults for hammer-vlsi.
# The values specified in this file are the defaults.
# e.g. foo: "bar" in this file means that the default setting for foo is "bar".

vlsi.core:
  # Path(s) to out-of-tree hammer technology libraries.
  technology_path: ["${vlsi.builtins.hammer_vlsi_path}/technology"]
  technology_path_meta: subst

  # Technology to use. hammer-vlsi will read this and load the appropriate technology libraries.
  technology: "saed32"

  # Technology node dimension (nm) to use.
  # Some tools change what they do as this changes.
  # TODO: move this to vlsi.technology
  node: 32

  # Path(s) to synthesis tools.
  # Add the built-in path to synthesis tools.
  synthesis_tool_path: ["${vlsi.builtins.hammer_vlsi_path}/synthesis"]
  synthesis_tool_path_meta: subst

  # Path(s) to place and route tools.
  # Add the built-in path to place and route tools.
  par_tool_path: ["${vlsi.builtins.hammer_vlsi_path}/par"]
  par_tool_path_meta: subst

  # Synthesis tool to use.
  # Currently we can choose from a selection of built-in tools which hammer-vlsi supports.
  synthesis_tool: "nop"

  # Place and route tool to use.
  par_tool: "nop"

  # Maximum threads to use in a CAD tool invocation.
  max_threads: 1

vlsi.technology:
  # Placement site for macros. (str)
  # Typically specified in standard cell LEFs.
  # See http://www.ispd.cc/contests/18/lefdefref.pdf
  # Required for some CAD tools to function properly.
  placement_site: null

cadence:
  # Path to the folder with defaults.yml for common Cadence settings.
  common_path: "${vlsi.builtins.hammer_vlsi_path}/common/cadence"
  common_path_meta: subst

# General VLSI inputs.
# These will vary per run of hammer-vlsi.
vlsi.inputs:
  # Supply voltages.
  supplies:
    VDD: "0.85 V"
    GND: "0 V"

  # Used by HammerDriver to generate configurations for hierarchical place-and-route.
  # type: (str)
  # Valid options:
  # none - Do nothing. (default)
  # manual - Read from hierarchical_manual_* below.
  # from_placement - Generate from "hierarchical" entries in vlsi.inputs.placement_constraints.
  hierarchical_definition: none

  # Manual hierarchical definitions used only if hierarchical_definition_source is set to manual mode.
  # Should be a list along the lines of [{"module1": "module1_sub1", "module1_sub2", "module2": "module2_sub"}].
  hierarchical_manual_modules: []

  # Manual hierarchical placement constraints used only if hierarchical_definition_source is set to manual mode.
  # Should be a list along the lines of [{"module1": <list of PlacementConstraint structs>}].
  hierarchical_manual_placement_constraints: []

  # Hierarchical par mode. (str)
  # Valid options:
  # flat - Perform a flat place and route run.
  # root - Root module in a hierarchical run - same as flat except that an extra write_ilm step is added.
  # hierarchical - Module which has sub-modules which are also hierarchical.
  # top - Top module in a hierarchical run - runs an extra assemble_design step.
  hierarchical_mode: flat

  # ILMs for hierarchical mode.
  # ILM struct (ILMStruct) members:
  # dir (str) - directory to the ILMs
  # module (str) - module name for the ILM
  # lef (str) - path to the LEF file
  ilms: []

  # Muli-mode multi-corner setups, overrides supplies
  # MMMC struct members:
  # name (str) - name of the corner.
  # type (str) - One of the following:
  # - "setup" (corner used for setup timing)
  # - "hold" (corner used for hold timing)
  # - "extra" (misc. corner potentially used for power analysis
  # voltage (str) - voltage of the corner should match tech json
  # temp (str) - temperature of the corner should mathc tech json
  mmmc_corners: []

  # Clock ports of the top-level module.
  # Clock struct members:
  # name (str) - Name of the clock port.
  # period (TimeValue) - Clock port period. e.g. "1 ns", "5ns". Default units: ns
  # port (str) - Optional. If specified, this is the RTL path to the clock. Otherwise, the path is the same as the name.
  # uncertainty (TimeValue) - Optional. Clock uncertainty. e.g. "1 ns", "5ns". Default units: ns
  clocks: []

  # Default output pin load capacitance.
  # Default: 1pF
  default_output_load: 1

  # List of output load constraints.
  # Each item in the list should be a struct with the following members:
  # name (str) - Name of the output load (e.g. io_out)
  # load (float) - Output load capacitance in pF.
  output_loads: []

  # List of placement constraints.
  # Each item is a struct member:
  # path (str) - Path to the given instance
  # type (str) - One of the following:
  # - "dummy" (does nothing with this constraint)
  # - "placement" (creates a placement constraint for an instance)
  # - "toplevel" (top-level chip dimensions; may only occur once, for the top-level module)
  # - "hardmacro" (places this hard macro at a particular spot)
  # - "hierarchical" (marks this instance as part of hierarchical place and route)
  # TODO(edwardw): add rotation
  # x (float) - x coordinate in um
  # y (float) - y coordinate in um
  # width (float) - width in um
  # height (float) - height in um
  placement_constraints: []

# Specific inputs for the synthesis tool.
# These inputs are the generic inputs; specific tools ("CAD junk") may require
# additional inputs.
# They will vary per run of hammer-vlsi.
synthesis.inputs:
  # Input files.
  # Typically a list of Verilog/VHDL files, depending on the synthesis tool.
  input_files: []

  # Top RTL module.
  # Set to null to not specify from the JSON.
  top_module: null


# Specific inputs for the place and route tool.
# These inputs are the generic inputs; specific tools ("CAD junk") may require
# additional inputs.
# They will vary per run of hammer-vlsi.
par.inputs:
  # Input post-synthesis netlist files.
  # Typically a list of Verilog/VHDL files, depending on the tool.
  # For place and route, these should typically be post-synthesis netlists.
  input_files: []

  # Top RTL module.
  top_module: null

  # Optional: SDC input file from post-synthesis.
  # Leave as null to not use.
  post_synth_sdc: null
