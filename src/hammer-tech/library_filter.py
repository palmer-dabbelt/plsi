#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  hammer-tech library filter.
#
#  Copyright 2017-2018 Edward Wang <edward.c.wang@compdigitec.com>

from numbers import Number
from typing import TYPE_CHECKING, Any, Callable, List, NamedTuple, Optional, Tuple, Union

from hammer_utils import get_or_else

if TYPE_CHECKING:
    # grumble grumble, we need a better Library class generator
    # Here is a stub class for type checking purposes only
    from hammer_tech import LibraryPrefix
    class Library:
        @property
        def extra_prefixes(self) -> List[LibraryPrefix]: pass
        @property
        def ecsm_liberty_file(self) -> Optional[str]: pass
        @property
        def gds_file(self) -> Optional[str]: pass
        @property
        def spice_file(self) -> Optional[str]: pass
        @property
        def verilog_synth(self) -> Optional[str]: pass

PathsFunctionType = Callable[["Library"], List[str]]
ExtractionFunctionType = Callable[["Library", List[str]], List[str]]


class LibraryFilter(NamedTuple('LibraryFilter', [
    ('tag', str),
    ('description', str),
    # Is the resulting string intended to be a file?
    ('is_file', bool),
    # Function to extract desired path(s) out of the library.
    # Returns either a list of library-relative paths.
    ('paths_func', PathsFunctionType),
    # Function to extract desired string(s) out of the library, given full
    # paths and the Library.
    # Returns a list of strings.
    ('extraction_func', Optional[ExtractionFunctionType]),
    # Additional filter function to use to exclude possible libraries.
    ('filter_func', Optional[Callable[["Library"], bool]]),
    # Sort function to control the order in which outputs are listed
    ('sort_func', Optional[Callable[["Library"], Union[Number, str, tuple]]]),
    # List of functions to call on the list-level (the list of elements generated by func) before output and
    # post-processing.
    ('extra_post_filter_funcs', List[Callable[[List[str]], List[str]]])
])):
    """
    "Library" filter containing a filtering function, identifier tag, and a short
    human-readable description.
    """
    __slots__ = ()

    @staticmethod
    def new(
            tag: str, description: str, is_file: bool,
            paths_func: PathsFunctionType,
            extraction_func: Optional[ExtractionFunctionType] = None,
            filter_func: Optional[Callable[["Library"], bool]] = None,
            sort_func: Optional[Callable[["Library"], Union[Number, str, tuple]]] = None,
            extra_post_filter_funcs: Optional[List[Callable[[List[str]], List[str]]]] = None) -> "LibraryFilter":
        """Convenience "constructor" with some default arguments."""

        # TODO(edwardw): call runtime checks here!!!

        return LibraryFilter(
            tag, description, is_file,
            paths_func,
            extraction_func,
            filter_func,
            sort_func,
            list(get_or_else(extra_post_filter_funcs, []))
        )
